import cv2
import numpy as np

# 道路提取流程
def extract_road(image):
    # 1. Sobel 邊緣檢測
    sobel_x = cv2.Sobel(image, cv2.CV_64F, 1, 0, ksize=3)
    sobel_y = cv2.Sobel(image, cv2.CV_64F, 0, 1, ksize=3)
    sobel_combined = cv2.magnitude(sobel_x, sobel_y)
    sobel_combined = np.uint8(cv2.normalize(sobel_combined, None, 0, 255, cv2.NORM_MINMAX))
    
    # 2. 自適應二值化
    binary_image = cv2.adaptiveThreshold(sobel_combined, 255, cv2.ADAPTIVE_THRESH_GAUSSIAN_C, 
                                         cv2.THRESH_BINARY, blockSize=15, C=5)
    
    # 3. 形態學操作 - 擴展遮罩
    kernel = cv2.getStructuringElement(cv2.MORPH_RECT, (3, 3))
    binary_image = cv2.morphologyEx(binary_image, cv2.MORPH_CLOSE, kernel)
    binary_image = cv2.morphologyEx(binary_image, cv2.MORPH_OPEN, kernel)
    
    return binary_image

# 填滿道路區域
def fill_road_area(original_image, road_mask):
    # 找出輪廓
    contours, _ = cv2.findContours(road_mask, cv2.RETR_EXTERNAL, cv2.CHAIN_APPROX_SIMPLE)
    result_image = cv2.cvtColor(original_image, cv2.COLOR_GRAY2BGR)
    
    for contour in contours:
        area = cv2.contourArea(contour)
        if area > 1000:  # 面積過小的輪廓不處理
            mask = np.zeros_like(road_mask)
            cv2.drawContours(mask, [contour], -1, 255, thickness=cv2.FILLED)
            
            # 僅填充灰度值低於特定門檻的區域
            result_image[np.logical_and(mask == 255, original_image < 80)] = (0, 255, 0)
    
    return result_image

# 主程式
def main():
    # 讀取單張影像
    image = cv2.imread('road.jpg', cv2.IMREAD_GRAYSCALE)
    
    # 道路提取
    road_mask = extract_road(image)
    
    # 填滿道路區域
    filled_road_image = fill_road_area(image, road_mask)
    
    # 使用 OpenCV 顯示影像
    cv2.imshow('Extracted Road Mask', road_mask)
    cv2.imshow('Filled Road Area', filled_road_image)
    
    # 等待按鍵關閉所有視窗
    cv2.waitKey(0)
    cv2.destroyAllWindows()

if __name__ == "__main__":
    main()
